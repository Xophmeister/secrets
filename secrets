#!/usr/bin/env bash

# Secrets
# A command line based secret manager

# License: GPLv3, or later
# Author: Christopher Harrison <ch12@sanger.ac.uk>
# Copyright (c) 2017 Genome Research Ltd.

set -eu -o pipefail

BINARY="$0"
PROGNAME="$(basename "${BINARY}")"
VERSION="0.0.1"

OS="$(uname -s)"
COPY=""
PASTE=""

GPG="gpg"
AWK="awk"
SHA256="sha256sum"

## Utility Functions ###################################################

stderr() {
  # Echo to stderr
  local message="$*"

  if [[ -t 2 ]]; then
    # Use ANSI red if stderr is a TTY
    message="\033[0;31m${message}\033[0m"
  fi

  >&2 echo -e "${message}"
}

has_dependencies() {
  # Check dependencies exist as commands
  local -a deps=("$@")

  for cmd in "${deps[@]}"; do
    command -v -- "${cmd}" &>/dev/null
  done
}

sha256() {
  # Return the SHA256 digest of the input
  local str="$*"
  echo -n "${str}" | ${SHA256} | grep -Eo "[a-f0-9]{64}"
}

nonce() {
  # Generate a 256-bit random hexadecimal string
  dd if=/dev/urandom bs=1 count=32 2>/dev/null | od -tx1 -An | tr -d "\n "
}

## Usage/Help Functions ################################################

usage() {
  local subcommand="${1:-}"

  case "${subcommand}" in
    "keep")
      cat <<-EOF
	Usage: ${PROGNAME} ${subcommand} [OPTIONS] SECRET_ID [SECRET]
	       ${PROGNAME} ${subcommand} (-h | --help)
	
	Keep a secret with the identifier of SECRET_ID. The secret can be
	specified with the plaintext given in SECRET, or generated following the
	rule policy provided by the options.
	
	Options:
	
	  --secrets FILE        Secrets file [~/.secrets]
	  --force               Overwrite the secret if it already exists
	  --length LENGTH       Length [16]
	  --allowed CLASS       Class of allowed characters [a-zA-Z0-9!?$%&=+_-]
	  --must-include CLASS  Class of characters that must be included (this
	                        option can be provided multiple times)
	  --copy                Copy the generated secret to the clipboard, if
	                        supported, rather than outputting to stdout
	  --expire SECONDS      Delete the secret from the clipboard, if used,
	                        after a time limit [30]
	
	The default policy will generate a secret with 284 bits of entropy.
	
	If the secrets file has not yet been created, you will be prompted for
	your GnuPG encryption and signing key IDs.
	EOF
    ;;

    "tell")
      cat <<-EOF
	Usage: ${PROGNAME} ${subcommand} [OPTIONS] SECRET_ID
	       ${PROGNAME} ${subcommand} (-h | --help)
	
	Tell the secret with the identifier of SECRET_ID.
	
	Options:
	
	  --secrets FILE        Secrets file [~/.secrets]
	  --copy                Copy the secret to the clipboard, if supported,
	                        rather than outputting to stdout
	  --expire SECONDS      Delete the secret from the clipboard, if used,
	                        after a time limit [30]
	EOF
    ;;

    "expose")
      cat <<-EOF
	Usage: ${PROGNAME} ${subcommand} [OPTIONS]
	       ${PROGNAME} ${subcommand} (-h | --help)
	
	Expose the list of all the available secret IDs.
	
	Options:
	
	  --secrets FILE        Secrets file [~/.secrets]
	  --with-date           Include the date the secret was told
	EOF
    ;;

    "forget")
      cat <<-EOF
	Usage: ${PROGNAME} ${subcommand} [OPTIONS] SECRET_ID
	       ${PROGNAME} ${subcommand} (-h | --help)
	
	Forget the secret with the identifier of SECRET_ID.
	
	Options:
	
	  --secrets FILE        Secrets file [~/.secrets]
	EOF
    ;;

    *)
      cat <<-EOF
	Usage: ${PROGNAME} SUBCOMMAND [OPTIONS]
	       ${PROGNAME} (-V | --version)
	       ${PROGNAME} (-h | --help)
	
	Subcommands:
	
	  keep    Keep a secret
	  tell    Tell a secret
	  expose  Expose the list of secret IDs
	  forget  Forget a secret
	
	The -h or --help option can be used against any subcommand for details.
	EOF
    ;;
  esac
}

show_version() {
  cat <<-EOF
	${PROGNAME} v${VERSION}
	Copyright (c) 2017 Genome Research Ltd.
	
	This program comes with ABSOLUTELY NO WARRANTY. This is free software,
	which you are welcome to redistribute under the conditions of the GNU
	Public License v3, or later.
	EOF
}

## Clipboard Handling Functions ########################################

copy() {
  # Copy input to clipboard and wipe it after a specified timeout
  if [[ "${COPY}" ]]; then
    local timeout="$1"
    local input="${*:2}"

    echo -n "${input}" | ${COPY}

    if (( timeout > 0 )); then
      # Clear the clipboard for non-zero timeouts
      "${BINARY}" __clear_clipboard "${timeout}" "${input}" &
    fi
  fi
}

paste() {
  # Echo contents of the clipboard to stdout
  if [[ "${PASTE}" ]]; then
    ${PASTE}
  fi
}

## GnuPG Handling Functions ############################################

# NOTE --with-colons output for key listings is described at
# http://git.gnupg.org/cgi-bin/gitweb.cgi?p=gnupg.git;a=blob_plain;f=doc/DETAILS

secret_key_ids() {
  # Output a list of secret key and subkey IDs
  "${GPG}" --list-secret-keys --with-colons 2>/dev/null \
  | "${AWK}" -F: '($1 ~ "sec|ssb") { print $5 }'
}

has_valid_secret_keys() {
  # Check that both valid signing and encryption (sub)keys exist

  # First we find the Key IDs of secret keys and subkeys, then we
  # reference these against the public keys to check their capabilities
  return "$("${GPG}" --list-keys --with-colons $(secret_key_ids) 2>/dev/null \
          | "${AWK}" -F: 'BEGIN { sign = 0; encrypt = 0; }
                          ($1 ~ "[ps]ub") && ($2 ~ "[mfu]") {
                            if ($12 ~ "s") sign++
                            if ($12 ~ "e") encrypt++
                          }
                          END { print !(sign * encrypt) }')"
}

keys_and_owners() {
  # Output a list of signing or encryption key IDs with their associated
  # user IDs in colon-delimited format (i.e., first field is key ID,
  # subsequent fields are user ID strings)
  local key_type

  case "$1" in
    "sign")    key_type="[sS]" ;;
    "encrypt") key_type="[eE]" ;;

    *) return 1 ;;
  esac

  "${GPG}" --list-keys --with-colons $(secret_key_ids) 2>/dev/null \
  | "${AWK}" -F: -v KEY_TYPE="${key_type}" '
    BEGIN { in_pub = 0; out = "" }
    $1 == "pub" {
      if (in_pub) print out
      in_pub = ($2 ~ "[mfu]") && ($12 ~ KEY_TYPE)
      if (in_pub) out = $5
    }
    in_pub && ($1 ~ "uid|[ps]ub") { if ($10) out = out ":" $10 }
    END { if (in_pub) print out }
  '
}

get_key() {
  # Return the selected signing or encryption key ID
  local key_type="$1"
  local key_data="$(keys_and_owners "${key_type}")"

  local full_type
  case "${key_type}" in
    "sign")    full_type="signing" ;;
    "encrypt") full_type="encryption" ;;

    *) return 1 ;;
  esac

  local -a valid_keys
  readarray -t valid_keys <<< "$(cut -d: -f1 <<< "${key_data}")"
  local total_keys="${#valid_keys[@]}"

  if (( total_keys == 1 )); then
    # If there's only one valid key, then just use that one
    echo "${valid_keys[0]}"
    return
  fi

  # Interactive key choice
  # IMPORTANT Redirect *everything* but the output to stderr

  # First the prompt...
  echo -e "Choose your ${full_type} key:\n" >&2
  "${AWK}" -F: -v COUNT="${total_keys}" '
    BEGIN {
      while (length(ind) < length(COUNT) + 20) ind = ind " "
    }
    {
      i++
      print i ". " $1 "  " $2
      for (j = 3; j <= NF; j++) print ind $j
      print ""
    }
  ' >&2 <<< "${key_data}"

  # ...then the user input
  local choice
  while true; do
    echo -n "Enter key number (1 to ${total_keys}): " >&2
    read -r choice

    if [[ "${choice}" =~ ^[0-9]+$ ]] && (( choice > 0 )) && (( choice <= total_keys )); then
      break
    fi
  done

  # Output chosen key ID to stdout
  echo "${valid_keys[$(( choice - 1 ))]}"
}

## Blockchain Functions ################################################

# We have a global blockchain... Gross, but bash isn't great at passing
# around large arrays between functions. This also saves us encrypting
# and decrypting the secrets file all the time.
#
# Tab-delimited fields, one record per line:
# TYPE  UID  TIMESTAMP  [PARAMS...]  NONCE  DIGEST
declare -a BLOCKCHAIN=()

read_blockchain() {
  # Read a blockchain from disk
  local filename="$(echo "$1")"

  if [[ -e "${filename}" ]]; then
    # Attempt to load blockchain from file
    local secrets
    if ! secrets="$("${GPG}" --decrypt "${filename}" 2>/dev/null)"; then
      stderr "Couldn't decrypt or validate ${filename}!"
      exit 1
    fi

    readarray -t BLOCKCHAIN <<< "${secrets}"

  else
    # Initialise empty blockchain
    touch "${filename}"
    BLOCKCHAIN=()
  fi
}

write_blockchain() {
  # Write the blockchain to disk
  local filename="$(echo "$1")"

  if (( "${#BLOCKCHAIN[@]}" == 0 )); then
    stderr "Can't write an empty blockchain!"
    exit 1
  fi

  # Get signing and encryption keys from genesis block
  local genesis_block="${BLOCKCHAIN[0]}"
  if ! [[ "$(cut -f1 <<< "${genesis_block}")" == "create" ]]; then
    stderr "Invalid genesis block!"
    exit 1
  fi

  local sign_key="$(cut -f4 <<< "${genesis_block}")"
  local encrypt_key="$(cut -f5 <<< "${genesis_block}")"

  # Encrypt and sign blockchain to disk
  for block in "${BLOCKCHAIN[@]}"; do echo "${block}"; done \
  | "${GPG}" --no-tty --yes \
             --sign --local-user "${sign_key}" \
             --encrypt --recipient "${encrypt_key}" \
             --output "${filename}" 2>/dev/null
}

add_block() {
  # Add a block to the chain
  local block_type="$1"
  local -a params=("${@:2}")

  # Get the previous block digest
  local prev_digest
  if (( "${#BLOCKCHAIN[@]}" == 0 )); then
    if ! [[ "${block_type}" == "create" ]]; then
      stderr "Invalid type for genesis block!"
      exit 1
    fi
    prev_digest="$(sha256 "")"

  else
    if [[ "${block_type}" == "create" ]]; then
      stderr "Cannot add genesis block to a non-empty blockchain!"
      exit 1
    fi
    local prev_block="${BLOCKCHAIN[-1]}"
    prev_digest="$(${AWK} -F'\t' '{ print $NF }' <<< "$prev_block")"
  fi

  local base_block="${block_type}	$(whoami)	$(date +%s)"
  local nonce_block
  local block_digest=""
  local block

  for param in "${params[@]}"; do
    base_block="${base_block}	${param}"
  done

  # Find the nonce that gives a digest starting with 00
  while ! [[ "${block_digest}" =~ ^00 ]]; do
    nonce_block="${base_block}	$(nonce)"
    block_digest="$(sha256 "${prev_digest}:$(sha256 "${nonce_block}")")"
  done

  # Add block to the chain
  block="${nonce_block}	${block_digest}"
  BLOCKCHAIN+=("${block}")
}

## Common ##############################################################

create_new_secrets_file() {
  local filename="$(echo "$1")"

  local sign_key="$(get_key sign)"
  local encrypt_key="$(get_key encrypt)"

  add_block "create" "${sign_key}" "${encrypt_key}"
  write_blockchain "${filename}"
}

## Keep a Secret #######################################################

main_keep() {
  local -a args=("$@")

  # TODO
  echo "KEEP!"
}

## Tell a Secret #######################################################

main_tell() {
  local -a args=("$@")

  # TODO
  echo "TELL!"
}

## Expose the Secret IDs ###############################################

main_expose() {
  local -a args=("$@")

  # TODO
  echo "EXPOSE!"
}

## Forget a Secret #####################################################

main_forget() {
  local -a args=("$@")

  # TODO
  echo "FORGET!"
}

## Initialisation and Entry-Point ######################################

initialise() {
  # Check dependencies, GnuPG status and initialise the copy and paste
  # functions, if they're available on the host platform
  if ! has_dependencies "${GPG}"; then
    stderr "${PROGNAME} requires GnuPG to be installed!"
    exit 1
  fi

  # We need either sha256sum or OpenSSL
  if ! has_dependencies "${SHA256}"; then
    if ! has_dependencies openssl; then
      stderr "${PROGNAME} requires either sha256sum or OpenSSL to calculate SHA256 digests!"
      exit 1
    fi
    SHA256="openssl dgst -sha256"
  fi

  if ! has_valid_secret_keys; then
    stderr "No valid encryption or signing keys found!"
    exit 1
  fi

  # Use GnuPG2 and Gnu AWK if they're available
  has_dependencies gpg2 && GPG="gpg2"
  has_dependencies gawk && AWK="gawk"

  case "${OS}" in
    "Darwin")
      # macOS
      COPY="pbcopy"
      PASTE="pbpaste"
      ;;

    "Linux" | *"BSD" | "DragonFly")
      # Linux or BSD running X11
      if [[ "${DISPLAY}" ]]; then
        COPY="xclip -i"
        PASTE="xclip -o"
      fi
      ;;
  esac

  local copy_cmd="${COPY%% *}"
  local paste_cmd="${PASTE%% *}"

  if ! ( [[ "${copy_cmd}" ]] || [[ "${paste_cmd}" ]] ) \
  || ! has_dependencies "${copy_cmd}" "${paste_cmd}"; then
    stderr "Clipboard functionality not supported!"
  fi

  # Set umask so only the user can read/write the secrets file
  umask 0177
}

main() {
  local -a args=("$@")
  local -a subcommand_args=("${args[@]:1}")

  case "${args[0]:-}" in
    "-h" | "--help")
      usage
      ;;

    "-V" | "--version")
      show_version
      ;;

    "keep" | "tell" | "expose" | "forget")
      local subcommand="${args[0]}"
      local help_re="-h|--help"

      if [[ "${subcommand_args[0]}" =~ ${help_re} ]]; then
        usage "${subcommand}"
      else
        "main_${subcommand}" "${subcommand_args[@]}"
      fi
      ;;

    "__clear_clipboard")
      # This is called internally to clear the clipboard after a defined
      # time period providing it matches the passed-in contents. It
      # should NOT be invoked manually!
      local timeout="${subcommand_args[0]}"
      local to_clear="${subcommand_args[*]:1}"

      sleep "${timeout}"
      if [[ "$(paste)" == "${to_clear}" ]]; then
        copy 0 ""
      fi
      ;;

    *)
      usage
      exit 1
      ;;
  esac
}

if [[ "${BASH_SOURCE[0]}" == "${BINARY}" ]]; then
  initialise
  main "$@"
fi
