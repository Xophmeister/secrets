#!/usr/bin/env bash

# Secrets
# A command line based secret manager

# License: GPLv3, or later
# Author: Christopher Harrison <ch12@sanger.ac.uk>
# Copyright (c) 2017 Genome Research Ltd.

# NOTE For debugging only
set -eu -o pipefail

BINARY="$0"
PROGNAME="$(basename "${BINARY}")"
VERSION="0.0.1"

OS="$(uname -s)"
COPY=""
PASTE=""

GPG="gpg"
AWK="awk"
SHA256="sha256sum"
SHUF="shuf"

NULL_DIGEST="e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855"

## Utility Functions ###################################################

stderr() {
  # Echo to stderr
  local message="$*"

  if [[ -t 2 ]]; then
    # Use ANSI red if stderr is a TTY
    message="\033[0;31m${message}\033[0m"
  fi

  >&2 echo -e "${message}"
}

has_dependencies() {
  # Check dependencies exist as commands
  local -a deps=("$@")

  for cmd in "${deps[@]}"; do
    command -v -- "${cmd}" &>/dev/null
  done
}

escape() {
  # Output escaped string
  printf "%q" "$*"
}

unescape() {
  # Output unescaped string
  # FIXME? This is potentially a code injection vector...
  bash -c "echo $1"
}

posix_shuf() {
  # POSIX-compliant shuf, if otherwise not available
  # Copyright (c) 2015 Michael Klement
  # https://stackoverflow.com/a/30133294/876937
  "${AWK}" 'BEGIN { srand(); OFMT="%.17f" } { print rand(), $0 }' "$@" \
  | sort -k1,1n \
  | cut -d ' ' -f2-
}

shuffle() {
  # Shuffle string
  fold -w1 <<< "$*" | ${SHUF} | tr -d "\n"
}

random_string() {
  # Create a random string
  local length="$1"
  local class="$2"

  LC_CTYPE=C tr -dc "${class}" </dev/urandom \
  | fold -w "${length}" \
  | head -1 \
  || true  # This nullifies the weird non-zero exit code
}

sha256() {
  # Return the SHA256 digest of the input
  local str="$*"
  echo -n "${str}" | ${SHA256} | grep -Eo "[a-f0-9]{64}"
}

nonce() {
  # Generate a 256-bit random hexadecimal string
  dd if=/dev/urandom bs=1 count=32 2>/dev/null | od -tx1 -An | tr -d "\n "
}

## Usage/Help Functions ################################################

usage() {
  local subcommand="${1:-}"

  case "${subcommand}" in
    "keep")
      cat <<-EOF
	Usage: ${PROGNAME} ${subcommand} [OPTIONS] SECRET_ID [SECRET]
	       ${PROGNAME} ${subcommand} (-h | --help)
	
	Keep a secret with the identifier of SECRET_ID. The secret can be
	specified with the plaintext given in SECRET, or generated following the
	rule policy provided by the options.
	
	Options:
	
	  --secrets FILE        Secrets file [~/.secrets]
	  --force               Overwrite the secret if it already exists
	  --length LENGTH       Length [16]
	  --allowed CLASS       Class of allowed characters [a-zA-Z0-9!?$%&=+_-]
	  --must-include CLASS  Class of characters that must be included (this
	                        option can be provided multiple times)
	  --copy                Copy the generated secret to the clipboard, if
	                        supported, rather than outputting to stdout
	  --expire SECONDS      Delete the secret from the clipboard, if used,
	                        after a time limit [30]
	
	The default policy will generate a secret with 284 bits of entropy.
	
	If the secrets file has not yet been created, you will be prompted for
	your GnuPG encryption and signing key IDs.
	EOF
    ;;

    "tell")
      cat <<-EOF
	Usage: ${PROGNAME} ${subcommand} [OPTIONS] SECRET_ID
	       ${PROGNAME} ${subcommand} (-h | --help)
	
	Tell the secret with the identifier of SECRET_ID.
	
	Options:
	
	  --secrets FILE        Secrets file [~/.secrets]
	  --copy                Copy the secret to the clipboard, if supported,
	                        rather than outputting to stdout
	  --expire SECONDS      Delete the secret from the clipboard, if used,
	                        after a time limit [30]
	EOF
    ;;

    "expose")
      cat <<-EOF
	Usage: ${PROGNAME} ${subcommand} [OPTIONS]
	       ${PROGNAME} ${subcommand} (-h | --help)
	
	Expose the list of all the available secret IDs.
	
	Options:
	
	  --secrets FILE        Secrets file [~/.secrets]
	  --with-date           Include the date the secret was told
	EOF
    ;;

    "forget")
      cat <<-EOF
	Usage: ${PROGNAME} ${subcommand} [OPTIONS] SECRET_ID
	       ${PROGNAME} ${subcommand} (-h | --help)
	
	Forget the secret with the identifier of SECRET_ID.
	
	Options:
	
	  --secrets FILE        Secrets file [~/.secrets]
	EOF
    ;;

    *)
      cat <<-EOF
	Usage: ${PROGNAME} SUBCOMMAND [OPTIONS]
	       ${PROGNAME} (-V | --version)
	       ${PROGNAME} (-h | --help)
	
	Subcommands:
	
	  keep    Keep a secret
	  tell    Tell a secret
	  expose  Expose the list of secret IDs
	  forget  Forget a secret
	
	The -h or --help option can be used against any subcommand for details.
	EOF
    ;;
  esac
}

show_version() {
  cat <<-EOF
	${PROGNAME} v${VERSION}
	Copyright (c) 2017 Genome Research Ltd.
	
	This program comes with ABSOLUTELY NO WARRANTY. This is free software,
	which you are welcome to redistribute under the conditions of the GNU
	Public License v3, or later.
	EOF
}

## Clipboard Handling Functions ########################################

copy() {
  # Copy input to clipboard and wipe it after a specified timeout
  if [[ "${COPY}" ]]; then
    local timeout="$1"
    local input="${*:2}"

    echo -n "${input}" | ${COPY}

    if (( timeout > 0 )); then
      # Clear the clipboard for non-zero timeouts
      "${BINARY}" __clear_clipboard "${timeout}" "${input}" &
    fi
  fi
}

paste() {
  # Echo contents of the clipboard to stdout
  if [[ "${PASTE}" ]]; then
    ${PASTE}
  fi
}

## GnuPG Handling Functions ############################################

# NOTE --with-colons output for key listings is described at
# http://git.gnupg.org/cgi-bin/gitweb.cgi?p=gnupg.git;a=blob_plain;f=doc/DETAILS

secret_key_ids() {
  # Output a list of secret key and subkey IDs
  "${GPG}" --list-secret-keys --with-colons 2>/dev/null \
  | "${AWK}" -F: '($1 ~ "sec|ssb") { print $5 }'
}

has_valid_secret_keys() {
  # Check that both valid signing and encryption (sub)keys exist

  # First we find the Key IDs of secret keys and subkeys, then we
  # reference these against the public keys to check their capabilities
  return "$("${GPG}" --list-keys --with-colons $(secret_key_ids) 2>/dev/null \
          | "${AWK}" -F: 'BEGIN { sign = 0; encrypt = 0; }
                          ($1 ~ "[ps]ub") && ($2 ~ "[mfu]") {
                            if ($12 ~ "s") sign++
                            if ($12 ~ "e") encrypt++
                          }
                          END { print !(sign * encrypt) }')"
}

keys_and_owners() {
  # Output a list of signing or encryption key IDs with their associated
  # user IDs in colon-delimited format (i.e., first field is key ID,
  # subsequent fields are user ID strings)
  local key_type

  case "$1" in
    "sign")    key_type="[sS]" ;;
    "encrypt") key_type="[eE]" ;;

    *) return 1 ;;
  esac

  "${GPG}" --list-keys --with-colons $(secret_key_ids) 2>/dev/null \
  | "${AWK}" -F: -v KEY_TYPE="${key_type}" '
    BEGIN { in_pub = 0; out = "" }
    $1 == "pub" {
      if (in_pub) print out
      in_pub = ($2 ~ "[mfu]") && ($12 ~ KEY_TYPE)
      if (in_pub) out = $5
    }
    in_pub && ($1 ~ "uid|[ps]ub") { if ($10) out = out ":" $10 }
    END { if (in_pub) print out }
  '
}

get_key() {
  # Return the selected signing or encryption key ID
  local key_type="$1"
  local key_data="$(keys_and_owners "${key_type}")"

  local full_type
  case "${key_type}" in
    "sign")    full_type="signing" ;;
    "encrypt") full_type="encryption" ;;

    *) return 1 ;;
  esac

  local -a valid_keys
  readarray -t valid_keys <<< "$(cut -d: -f1 <<< "${key_data}")"
  local total_keys="${#valid_keys[@]}"

  if (( total_keys == 1 )); then
    # If there's only one valid key, then just use that one
    echo "${valid_keys[0]}"
    return
  fi

  # Interactive key choice
  # IMPORTANT Redirect *everything* but the output to stderr

  # First the prompt...
  echo -e "Choose your ${full_type} key:\n" >&2
  "${AWK}" -F: -v COUNT="${total_keys}" '
    BEGIN {
      while (length(ind) < length(COUNT) + 20) ind = ind " "
    }
    {
      i++
      print i ". " $1 "  " $2
      for (j = 3; j <= NF; j++) print ind $j
      print ""
    }
  ' >&2 <<< "${key_data}"

  # ...then the user input
  local choice
  while true; do
    echo -n "Enter key number (1 to ${total_keys}): " >&2
    read -r choice

    if [[ "${choice}" =~ ^[0-9]+$ ]] && (( choice > 0 )) && (( choice <= total_keys )); then
      break
    fi
  done

  # Output chosen key ID to stdout
  echo "${valid_keys[$(( choice - 1 ))]}"
}

## Blockchain Functions ################################################

# We have a global blockchain... Gross, but bash isn't great at passing
# around large arrays between functions. This also saves us encrypting
# and decrypting the secrets file all the time.
#
# Tab-delimited fields, one record per line:
# TYPE  UID  TIMESTAMP  [PARAMS...]  NONCE  DIGEST
declare -a BLOCKCHAIN=()

read_blockchain() {
  # Read a blockchain from disk
  local filename="$(echo "$1")"

  if [[ -e "${filename}" ]]; then
    # Attempt to load blockchain from file
    local secrets
    if ! secrets="$("${GPG}" --decrypt "${filename}" 2>/dev/null)"; then
      stderr "Couldn't decrypt or validate ${filename}!"
      exit 1
    fi

    readarray -t BLOCKCHAIN <<< "${secrets}"

    # Validate the last block on every block
    #           ...last five blocks on every fifth block
    #           ...whole blockchain on every 25th block
    local chain_length="${#BLOCKCHAIN[@]}"
    local to_validate="$(( chain_length % 25 ? chain_length % 5 ? 1 : 5 : 0 ))"

    if ! validate_chain "${to_validate}"; then
      stderr "Your secrets have been compromised! Flee immediately!"
      exit 1
    fi

  else
    # Initialise empty blockchain
    touch "${filename}"
    BLOCKCHAIN=()
  fi
}

write_blockchain() {
  # Write the blockchain to disk
  local filename="$(echo "$1")"

  if (( "${#BLOCKCHAIN[@]}" == 0 )); then
    stderr "Can't write an empty blockchain!"
    exit 1
  fi

  # Get signing and encryption keys from genesis block
  local genesis_block="${BLOCKCHAIN[0]}"
  if [[ "$(cut -f1 <<< "${genesis_block}")" != "genesis" ]]; then
    stderr "Invalid genesis block!"
    exit 1
  fi

  local sign_key="$(cut -f4 <<< "${genesis_block}")"
  local encrypt_key="$(cut -f5 <<< "${genesis_block}")"

  # Encrypt and sign blockchain to disk
  for block in "${BLOCKCHAIN[@]}"; do echo "${block}"; done \
  | "${GPG}" --no-tty --yes \
             --sign --local-user "${sign_key}" \
             --encrypt --recipient "${encrypt_key}" \
             --output "${filename}" 2>/dev/null
}

add_block() {
  # Add a block to the chain
  local block_type="$1"
  local -a params=("${@:2}")

  # Get the previous block digest
  local prev_digest
  if (( "${#BLOCKCHAIN[@]}" == 0 )); then
    if [[ "${block_type}" == "genesis" ]]; then
      prev_digest="${NULL_DIGEST}"
    else
      # Automatically add genesis block
      local sign_key="$(get_key sign)"
      local encrypt_key="$(get_key encrypt)"

      add_block "genesis" "${sign_key}" "${encrypt_key}"
    fi
  else
    if [[ "${block_type}" == "genesis" ]]; then
      stderr "Cannot add genesis block to a non-empty blockchain!"
      exit 1
    fi
    local prev_block="${BLOCKCHAIN[-1]}"
    prev_digest="$(rev <<< "${prev_block}" | cut -f1 | rev)"
  fi

  # This can take a while, so let the user know what's going on
  >&2 echo -n "Calculating \"${block_type}\" block... "

  local base_block="${block_type}	$(whoami)	$(date +%s)"
  local nonce_block
  local block_digest=""
  local block

  for param in "${params[@]}"; do
    base_block="${base_block}	${param}"
  done

  # Find the nonce that gives a digest starting with 00
  while ! [[ "${block_digest}" =~ ^00 ]]; do
    nonce_block="${base_block}	$(nonce)"
    block_digest="$(sha256 "${prev_digest}:$(sha256 "${nonce_block}")")"
  done

  # Add block to the chain
  block="${nonce_block}	${block_digest}"
  BLOCKCHAIN+=("${block}")
  >&2 echo "Done!"
}

validate_block() {
  # Validate the hash of a specific block
  local index="$1"
  local chain_length="${#BLOCKCHAIN[@]}"

  # Can't validate empty chain
  if (( chain_length == 0 )); then
    return 1
  fi

  # Normalise index
  if (( index < 0 )); then
    index="$(( chain_length + index ))"
  fi

  # Check index bounds
  if (( index < 0 )) || (( index >= chain_length )); then
    return 1
  fi

  local block="${BLOCKCHAIN[${index}]}"
  local block_digest="$(rev <<< "${block}" | cut -f1 | rev)"
  local digestless_block="$(rev <<< "${block}" | cut -f2- | rev )"

  local prev_digest
  if (( index == 0 )); then
    prev_digest="${NULL_DIGEST}"
  else
    local prev_block="${BLOCKCHAIN[$(( index - 1 ))]}"
    prev_digest="$(rev <<< "${prev_block}" | cut -f1 | rev)"
  fi

  local calc_digest="$(sha256 "${prev_digest}:$(sha256 "${digestless_block}")")"
  if [[ "${block_digest}" != "${calc_digest}" ]]; then
    return 1
  fi
}

validate_chain() {
  # Validate the tail (and potentially all) of the chain
  local blocks="${1:-0}"
  local chain_length="${#BLOCKCHAIN[@]}"

  # Can't validate empty chain
  if (( chain_length == 0 )); then
    return 1
  fi

  # Validate everything
  if (( blocks == 0 )) || (( blocks > chain_length )); then
    blocks="${chain_length}"
  fi

  for index in $(seq -1 -${blocks}); do
    if ! validate_block "${index}"; then
      return 1
    fi
  done
}

## Keep a Secret #######################################################

generate_password() {
  # Generate password
  local length="$1"
  local allowed="$2"
  local -a must_include=("${@:3}")

  local password=""

  for class in "${must_include[@]}"; do
    password="${password}$(random_string 1 "${class}")"
  done

  local remainder="$(( length - "${#must_include[@]}" ))"
  if (( remainder > 0 )); then
    password="${password}$(random_string "${remainder}" "${allowed}")"
  fi

  shuffle "${password}"
}

main_keep() {
  local arg
  local show_help=""
  local bad_args=""

  local secret_id=""
  local secret=""

  local secrets_file="~/.secrets"
  local force=""
  local length="16"
  local allowed='a-zA-Z0-9!?$%&=+_-'
  local -a must_include=()
  local copy_output=""
  local expire="30"

  while (( "$#" )); do
    arg="$1"

    case "${arg}" in
      "-h" | "--help")
        show_help="1"
        ;;

      "--secrets")
        shift
        if [[ -z "${1+x}" ]]; then
          bad_args="1"
          break
        else
          secrets_file="$1"
        fi
        ;;

      "--force")
        force="1"
        ;;

      "--length")
        shift
        if [[ -z "${1+x}" ]]; then
          bad_args="1"
          break
        else
          length="$1"
          if ! [[ "${length}" =~ ^[0-9]+$ ]]; then
            stderr "Secret length must be a number!"
            bad_args="1"
          else
            if (( length == 0 )); then
              stderr "Secret length must be greater than zero!"
              bad_args="1"
            fi
          fi
        fi
        ;;

      "--allowed")
        shift
        if [[ -z "${1+x}" ]]; then
          bad_args="1"
          break
        else
          # TODO It would be nice to validate this
          allowed="$1"
        fi
        ;;

      "--must-include")
        shift
        if [[ -z "${1+x}" ]]; then
          bad_args="1"
          break
        else
          # TODO It would be nice to validate this
          must_include+=("$1")
        fi
        ;;

      "--copy")
        copy_output="1"
        ;;

      "--expire")
        shift
        if [[ -z "${1+x}" ]]; then
          bad_args="1"
          break
        else
          expire="$1"
          if ! [[ "${expire}" =~ ^[0-9]+$ ]]; then
            stderr "Clipboard expiry time must be a number!"
            bad_args="1"
          fi
        fi
        ;;

      *)
        if ! [[ "${secret_id}" ]]; then
          secret_id="$(escape "${arg}")"
        else
          if ! [[ "${secret}" ]]; then
            secret="$(escape "${arg}")"
          else
            stderr "Can only assign one secret to one ID at a time!"
            bad_args="1"
          fi
        fi
        ;;
    esac

    if [[ "${bad_args}" ]]; then break; fi
    shift
  done

  # We can't have more requirements than allowed by the length
  if (( "${#must_include[@]}" > "${length}" )); then
    stderr "Can't fit ${#must_include[@]} requirements into a secret of length ${length}!"
    bad_args="1"
  fi

  # Show help, if requested or the input was bad
  if [[ "${show_help}" ]] || [[ "${bad_args}" ]]; then
    usage "keep"
    exit $(( "${bad_args}" ))
  fi

  # TODO
  echo "KEEP!"
}

## Tell a Secret #######################################################

main_tell() {
  local -a args=("$@")

  # TODO
  echo "TELL!"
}

## Expose the Secret IDs ###############################################

main_expose() {
  local -a args=("$@")

  # TODO
  echo "EXPOSE!"
}

## Forget a Secret #####################################################

main_forget() {
  local -a args=("$@")

  # TODO
  echo "FORGET!"
}

## Initialisation and Entry-Point ######################################

initialise() {
  # Check dependencies, GnuPG status and initialise the copy and paste
  # functions, if they're available on the host platform
  if ! has_dependencies "${GPG}"; then
    stderr "${PROGNAME} requires GnuPG to be installed!"
    exit 1
  fi

  # We need either sha256sum or OpenSSL
  if ! has_dependencies "${SHA256}"; then
    if ! has_dependencies openssl; then
      stderr "${PROGNAME} requires either sha256sum or OpenSSL to calculate SHA256 digests!"
      exit 1
    fi
    SHA256="openssl dgst -sha256"
  fi

  # shuf > gshuf > posix_shuf
  if ! has_dependencies "${SHUF}"; then
    if has_dependencies gshuf; then
      SHUF="gshuf"
    else
      SHUF="posix_shuf"
    fi
  fi

  if ! has_valid_secret_keys; then
    stderr "No valid encryption or signing keys found!"
    exit 1
  fi

  # Use GnuPG2 and Gnu AWK if they're available
  has_dependencies gpg2 && GPG="gpg2"
  has_dependencies gawk && AWK="gawk"

  case "${OS}" in
    "Darwin")
      # macOS
      COPY="pbcopy"
      PASTE="pbpaste"
      ;;

    "Linux" | *"BSD" | "DragonFly")
      # Linux or BSD running X11
      if [[ "${DISPLAY}" ]]; then
        COPY="xclip -i"
        PASTE="xclip -o"
      fi
      ;;
  esac

  if ! has_dependencies "${SHUF}"; then
    stderr "${PROGNAME} requires the GNU coreutils to be installed!"
    exit 1
  fi

  local copy_cmd="${COPY%% *}"
  local paste_cmd="${PASTE%% *}"

  if ! ( [[ "${copy_cmd}" ]] || [[ "${paste_cmd}" ]] ) \
  || ! has_dependencies "${copy_cmd}" "${paste_cmd}"; then
    stderr "Clipboard functionality not supported!"
  fi

  # Set umask so only the user can read/write the secrets file
  umask 0177
}

main() {
  local -a args=("$@")
  local -a subcommand_args=("${args[@]:1}")

  case "${args[0]:-}" in
    "-h" | "--help")
      usage
      ;;

    "-V" | "--version")
      show_version
      ;;

    "keep" | "tell" | "expose" | "forget")
      local subcommand="${args[0]}"
      local help_re="-h|--help"

      if [[ "${subcommand_args[0]}" =~ ${help_re} ]]; then
        usage "${subcommand}"
      else
        "main_${subcommand}" "${subcommand_args[@]}"
      fi
      ;;

    "__clear_clipboard")
      # This is called internally to clear the clipboard after a defined
      # time period providing it matches the passed-in contents. It
      # should NOT be invoked manually!
      local timeout="${subcommand_args[0]}"
      local to_clear="${subcommand_args[*]:1}"

      sleep "${timeout}"
      if [[ "$(paste)" == "${to_clear}" ]]; then
        copy 0 ""
      fi
      ;;

    *)
      usage
      exit 1
      ;;
  esac
}

if [[ "${BASH_SOURCE[0]}" == "${BINARY}" ]]; then
  initialise
  main "$@"
fi
