#!/usr/bin/env bash

# Secrets
# A command line based secret manager

# License: GPLv3, or later
# Author: Christopher Harrison <ch12@sanger.ac.uk>
# Copyright (c) 2017 Genome Research Ltd.

BINARY="$0"
PROGNAME="$(basename "${BINARY}")"
VERSION="0.0.1"

OS="$(uname -s)"
COPY=""
PASTE=""

## Utility Functions ###################################################

stderr() {
  # Echo to stderr
  local message="$*"

  if [[ -t 2 ]]; then
    # Use ANSI red if stderr is a TTY
    message="\033[0;31m${message}\033[0m"
  fi

  >&2 echo -e "${message}"
}

has_dependencies() {
  # Check dependencies exist as commands
  local -a deps=("$@")

  for cmd in "${deps[@]}"; do
    command -v -- "${cmd}" &>/dev/null
  done
}

## Usage/Help Functions ################################################

usage() {
  local subcommand="${1:-}"

  case "${subcommand}" in
    "keep")
      cat <<-EOF
	Usage: ${PROGNAME} ${subcommand} [OPTIONS] SECRET_ID [SECRET]
	       ${PROGNAME} ${subcommand} (-h | --help)
	
	Keep a secret with the identifier of SECRET_ID. The secret can be
	specified with the plaintext given in SECRET, or generated following the
	rule policy provided by the options.
	
	Options:
	
	  --secrets FILE        Secrets file [~/.secrets]
	  --force               Overwrite the secret if it already exists
	  --length LENGTH       Length [16]
	  --allowed CLASS       Class of allowed characters [a-zA-Z0-9!?$%&=+_-]
	  --must-include CLASS  Class of characters that must be included (this
	                        option can be provided multiple times)
	  --copy                Copy the generated secret to the clipboard, if
	                        supported, rather than outputting to stdout
	  --expire SECONDS      Delete the secret from the clipboard, if used,
	                        after a time limit [30]
	
	The default policy will generate a secret with 284 bits of entropy.
	
	If the secrets file has not yet been created, you will be prompted for
	your GnuPG encryption and signing key IDs.
	EOF
    ;;

    "tell")
      cat <<-EOF
	Usage: ${PROGNAME} ${subcommand} [OPTIONS] SECRET_ID
	       ${PROGNAME} ${subcommand} (-h | --help)
	
	Tell the secret with the identifier of SECRET_ID.
	
	Options:
	
	  --secrets FILE        Secrets file [~/.secrets]
	  --copy                Copy the secret to the clipboard, if supported,
	                        rather than outputting to stdout
	  --expire SECONDS      Delete the secret from the clipboard, if used,
	                        after a time limit [30]
EOF
    ;;

    "expose")
      cat <<-EOF
	Usage: ${PROGNAME} ${subcommand} [OPTIONS]
	       ${PROGNAME} ${subcommand} (-h | --help)
	
	Expose the list of all the available secret IDs.
	
	Options:
	
	  --secrets FILE        Secrets file [~/.secrets]
	  --with-date           Include the date the secret was told
	EOF
    ;;

    "forget")
      cat <<-EOF
	Usage: ${PROGNAME} ${subcommand} [OPTIONS] SECRET_ID
	       ${PROGNAME} ${subcommand} (-h | --help)
	
	Forget the secret with the identifier of SECRET_ID.
	
	Options:
	
	  --secrets FILE        Secrets file [~/.secrets]
	EOF
    ;;

    *)
      cat <<-EOF
	Usage: ${PROGNAME} SUBCOMMAND [OPTIONS]
	       ${PROGNAME} (-V | --version)
	       ${PROGNAME} (-h | --help)
	
	Subcommands:
	
	  keep    Keep a secret
	  tell    Tell a secret
	  expose  Expose the list of secret IDs
	  forget  Forget a secret
	
	The -h or --help option can be used against any subcommand for details.
	EOF
    ;;
  esac
}

show_version() {
  cat <<-EOF
	${PROGNAME} v${VERSION}
	Copyright (c) 2017 Genome Research Ltd.
	
	This program comes with ABSOLUTELY NO WARRANTY. This is free software,
	which you are welcome to redistribute under the conditions of the GNU
	Public License v3, or later.
	EOF
}

## Clipboard Handling Functions ########################################

copy() {
  # Copy input to clipboard and wipe it after a specified timeout
  if [[ "${COPY}" ]]; then
    local timeout="$1"
    local input="${*:2}"

    echo -n "${input}" | ${COPY}

    if (( timeout > 0 )); then
      # Clear the clipboard for non-zero timeouts
      "${BINARY}" __clear_clipboard "${timeout}" "${input}" &
    fi
  fi
}

paste() {
  # Echo contents of the clipboard to stdout
  if [[ "${PASTE}" ]]; then
    ${PASTE}
  fi
}

## GnuPG Handling Functions ############################################

valid_secret_keys() {
  # Return a list of valid secret key IDs with the given capability
  local capability="$1"
  gpg --list-secret-keys --with-colons \
  | awk -F: -v CAPABILITY="${capability}" \
        '($1 ~ "sec|ssb") && ($2 ~ "[mfu]") && ($12 ~ CAPABILITY) { print $5 }'
}

## Keep a Secret #######################################################

main_keep() {
  local -a args=("$@")

  # TODO
  echo "KEEP!"
}

## Tell a Secret #######################################################

main_tell() {
  local -a args=("$@")

  # TODO
  echo "TELL!"
}

## Expose the Secret IDs ###############################################

main_expose() {
  local -a args=("$@")

  # TODO
  echo "EXPOSE!"
}

## Forget a Secret #####################################################

main_forget() {
  local -a args=("$@")

  # TODO
  echo "FORGET!"
}

## Initialisation and Entry-Point ######################################

initialise() {
  # Check dependencies, GnuPG status and initialise the copy and paste
  # functions, if they're available on the host platform
  if ! has_dependencies gpg jq; then
    stderr "${PROGNAME} requires both GnuPG and jq to be installed!"
    exit 1
  fi

  if (( $(valid_secret_keys "e" | wc -l) == 0 )) || (( $(valid_secret_keys "s" | wc -l) == 0 )); then
    stderr "No valid encryption or signing keys found!"
    exit 1
  fi

  case "${OS}" in
    "Darwin")
      COPY="pbcopy"
      PASTE="pbpaste"
      ;;

    "Linux")
      COPY="xclip -i"
      PASTE="xclip -o"
      ;;
  esac

  local copy_cmd="${COPY%% *}"
  local paste_cmd="${PASTE%% *}"

  if ! ( [[ "${copy_cmd}" ]] || [[ "${paste_cmd}" ]] ) \
  || ! has_dependencies "${copy_cmd}" "${paste_cmd}"; then
    stderr "Clipboard functionality not supported!"
  fi
}

main() {
  local -a args=("$@")
  local -a subcommand_args=("${args[@]:1}")

  case "${args[0]:-}" in
    "-h" | "--help")
      usage
      ;;

    "-V" | "--version")
      show_version
      ;;

    "keep" | "tell" | "expose" | "forget")
      local subcommand="${args[0]}"
      local help_re="-h|--help"

      if [[ "${subcommand_args[0]}" =~ ${help_re} ]]; then
        usage "${subcommand}"
      else
        "main_${subcommand}" "${subcommand_args[@]}"
      fi
      ;;

    "__clear_clipboard")
      # This is called internally to clear the clipboard after a defined
      # time period providing it matches the passed-in contents. It
      # should NOT be invoked manually!
      local timeout="${subcommand_args[0]}"
      local to_clear="${subcommand_args[*]:1}"

      sleep "${timeout}"
      if [[ "$(paste)" == "${to_clear}" ]]; then
        copy 0 ""
      fi
      ;;

    *)
      usage
      exit 1
      ;;
  esac
}

if [[ "${BASH_SOURCE[0]}" == "${BINARY}" ]]; then
  initialise
  main "$@"
fi
